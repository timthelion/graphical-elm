{-
This module provides utilities for:
 - Generating Elm code from internal data structures.
 - Parsing that generated Elm code.

copyright (c) 2013 Timothy Hobbs
Released under the terms of the GNU AGPL v 3 or later.
See more licence information at the end of the file, and or in the file COPYING.
-}
module CodeGenerator where
import String
import List
import Either

import open Graph
import open GraphEditorState
import Ikcilpazc

header          = "{-GENERATED BY GRAPHICALELM0.0-}"
miscEntryMarker = "{-MISC_ENTRY-}"
eolMarker       = "{-*****-}"


headerLength = String.length header

generateCode: GraphEditorState -> String
generateCode ges
 =
 let
  nodeCodesE = map generateNodeCode ges.graph
  errors = Either.lefts nodeCodesE
  nodeCodes = Either.rights nodeCodesE
 in
 if | length errors == 0 ->
      header ++ "\n" ++
      (concat <| map (\misc->misc++"{-MISC_ENTRY-}"++eolMarker++"\n") ges.misc) ++
      (concat <| nodeCodes)
    | otherwise -> concat <| errors

generateNodeCode: Node -> Either.Either String String
generateNodeCode node =
 case (case node.value.language of
   ElmLang -> Either.Right (node.value.code)
   Ikcilpazc -> Ikcilpazc.gen node) of
  Either.Right code -> Either.Right <| node.name++"="++ code ++ "{-_language_"++show node.value.language++"_base_code_#####$#"++node.value.code++"#$#####_parents_-}"++(concat <| intersperse "~" node.parents)++ eolMarker++"\n"
  Either.Left err -> Either.Left err

parseSavedGraph: String -> Either.Either String GraphEditorState
parseSavedGraph content =
 if String.startsWith header content
 then
  (  String.split eolMarker (String.dropLeft headerLength content)
  |> foldl parseEntry (Either.Right emptyEditorState))
 else Either.Left <| "Error loading file: Header does not match."

parseEntry: String -> Either.Either String GraphEditorState -> Either.Either String GraphEditorState
parseEntry entry gesE =
 let
  parseMisc' ges =
   case parseMisc entry of
    (Parsed m)  -> Either.Right {ges|misc<-m::ges.misc}
    Drop        -> Either.Right ges
    (Error err) -> Either.Left  err
  parseSavedNode' ges =
   case parseSavedNode entry of
    (Parsed n)  -> Either.Right {ges|graph<-n::ges.graph}
    Drop        -> Either.Right ges
    (Error err) -> Either.Left  err
 in
 case gesE of
  (Either.Right ges) ->
   if | String.contains miscEntryMarker entry -> parseMisc' ges
      | otherwise -> parseSavedNode' ges
  (Either.Left err) -> Either.Left err

data Parsed a = Parsed a | Drop | Error String

parseSavedNode: String -> Parsed Node
parseSavedNode raw =
 let
  headSplit = String.split "=" <| String.dropLeft 1 raw
  name = head headSplit
 in
 if raw == ""
 then Drop
 else
 case String.split "{-_language_" (head <| List.drop 1 headSplit) of
  (_::raw'::[]) ->
   let
    languageString = head <| String.split "_base_code_" raw'
    language =
     if | languageString == "ElmLang" -> ElmLang
        | languageString == "Ikcilpazc" -> Ikcilpazc
    code = inQuotes "#####$#" "#$#####" raw'
    parents' =
     case String.split "_parents_-}" raw' of
      (_::raw''::[]) -> String.split "~" raw''
    parents =
     case parents' of
      (p::[]) -> if | p == "" -> []
                    | otherwise -> parents'
      _ -> parents'
   in Parsed {name=name,parents=parents,value={code=code,language=language}}
  _ -> Error <| "Parse error, cannot parse:" ++ raw

parseMisc: String -> Parsed String
parseMisc miscEntry = Parsed <| String.dropRight (String.length miscEntryMarker) miscEntry

inQuotes: String -> String -> String -> String
inQuotes startQuote endQuote fullString =
 case String.split startQuote fullString of
  (_::afterQuote::[]) ->
   case String.split endQuote afterQuote of
    (inQuotes'::_) -> inQuotes'
{-
Graphical ELM - A program for editing graphs as graphs.
Visually, Architecturally

    Copyright (C) 2013  Timothy Hobbs <timothyhobbs@seznam.cz> thobbs.cz

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as
    published by the Free Software Foundation, either version 3 of the
    License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-}